chromium for android Browser进程创建过程分析
ContentMainDelegate是客户端程序注册给content_main_runner.cc的回调接口，
content_main_runner.cc通过调用ContentMainDelegate的接口来通知客户端当前Content框架的状态。
客户端程序通过ContentMainDelegate::RegisterApplicationNativeMethods接口注册自己的本地方法。
ContentMainDelegate中的有四个函数：
CreateContentBrowserClient();
CreateContentPluginClient();
CreateContentRendererClient();
CreateContentUtilityClient();
用来分别创建ContentBrowserClient，ContentPlunginClient，ContentRendererClient，ContentUtilityClient的实例。
ContentMainDelegate的注册过程如下：
图片Chrome_contentMainDelegate.jpg
虚拟机在动态库加载完成后调用全局函数JNI_OnLoad,定义在chrome_jni_onload.cc中。
JNI_OnLoad调用全局函数RunChrome，定义在chrome_android_initializer.cc中。
RunChrome调用content命名空间的全局函数SetContentMainDelegate()定义在content_main.cc中。
SetContentMainDelegate()将指向ChromeMainDelegateAndroid对象的指针保存到全局变量g_content_main_delegate中。
content_main.cc的Start方法会构建一个ContentMainRunner的实例，并将变量g_content_main_delegate传递给ContentMainRunner实例。
content_main_runner.cc中调用的ContentMainDelegate中的所有函数。

android平台的chromium框架由ContentMain.java负责初始化所有类型的进程。 
content_switches.cc中定义了chromium所有的进程类型，如BrowserProcess,RendererProcess，PluginProcess，WorkerProcess，UtilityProcess等。
应用程序创建Browser进程的过程如下：
browserprocesscreated.jpg
ContentMain.java只有两个方法：
public static void initApplicationContext(Context context)；
public static int start()；
客户端程序需要先调用initApplicationContext接口，再调用start接口，才会触发Browser进程或Render进程的创建。
ContentMain.java的jni层对应文件是src/content/app/android/content_main.cc.
将ContentMain.java与content_main.cc连接起来的是Chromium自动生成的jni文件：ContentMain_jni.h
Chromium的jni文件的命名规则是java文件名_jni.h.
编译后这个文件位于：src/out/Release/gen/content/jni
ContentMain.java中的两个方法只是简单的调用native层content_main.cc中的全局函数。
content_main.cc中的start函数主要做三件事：
1.创建一个ContentMainRunner实例,实际创建的是继承自ContentMainRunner的ContentMainRunnerImpl,这个类定义在content_main_runner.cc中；
2.调用ContentMainRunnerImpl实例的Initialize接口，同时将ContentMainDelegate实例传给ContentMainRunnerImpl；
3.调用ContentMainRunnerImpl实例的Run接口；
ContentMainRunnerImpl::Initialize接口调用ContentClientInitializer::Set(process_type, delegate_)，
ContentClientInitializer定义在content_main_runner.cc中，这个类只有一个static方法Set,
Set方法的职责是调用ContentMainDelegate的相应接口设置ContentClient的实例域ContentBrowserClient，ContentPluginClient,ContentRenderClient,ContentUtilityClient。

ContentMainRunnerImpl::Run会调用全局函数RunNamedProcessTypeMain，这个函数中会调用ContentMainDelegate::RunProcess.
根据前面对ContentMainDelegate的讨论，我们知道实际执行的是ChromeMainDelegateAndroid::RunProcess.
ChromeMainDelegateAndroid::RunProcess主要做两件事：
1.创建BrowserMainRunner实例，实际创建的是继承自BrowserMainRunner的BrowserMainRunnerImpl,这个类定义在browser_main_runner.cc中；
2.调用BrowserMainRunnerImpl实例的Initialize接口。
BrowserMainRunnerImpl包含BrowserMainLoop的引用。
BrowerMainLoop是Browser进程的核心类，负责Browser进程中所有线程的创建。
BrowserMainRunnerImpl::Initialize函数创建BrowserMainLoop的实例并调用其接口完成Browser进程的准备工作。
上述类之间的关系图如下：


BrowserMainLoop::init()函数会调用ContentBrowserClient生成BrowserMainParts.
parts_.reset(GetContentClient()->browser()->CreateBrowserMainParts(parameters_));




ContentMainRunnerImpl中的initialize和run函数通过如下方式获得当前进程的类型：
const CommandLine& command_line = *CommandLine::ForCurrentProcess();
std::string process_type =command_line.GetSwitchValueASCII(switches::kProcessType);





































